---
title: "Test"
author: "John Mohoang (mohoang2)"
date: "5/5/2020"
output: html_document
---

### 6. Appendix  
```{r eval=FALSE, include=TRUE}
###################################################################################
# Libraries
###################################################################################
library(rjags)
library(lattice)


###################################################################################
# Q2
# Number of deaths versus day plot
###################################################################################

eucoviddeaths <- read.csv('EUCOVIDdeaths.csv', header = TRUE)

colors <- c("#285F17", "#EB5528", "#27466C", "#853B3D", "#748D84",
            "#955735", "#EF8632", "#EA33F7", "#75FBFD", "#EA3323",
            "#75FB4C", "#988950", "#75147C", "#C5DBC2", "#B6D7E4")

plot(16:31, eucoviddeaths[1, 3:18], type='l', col=colors[1], main = "number of deaths versus day", xlab='March 2020', ylab='# deaths', ylim=c(0, max(eucoviddeaths[, 3:18])))
for(i in 2:nrow(eucoviddeaths)) {
  lines(16:31, eucoviddeaths[i, 3:18], col=colors[i])
  
}
legend("topleft", legend = paste(eucoviddeaths$Country), col = colors[1:15], pch = 19, bty = "n")


###################################################################################
# Q2
# Number of deaths per capita versus day plot
###################################################################################

plot(16:31, eucoviddeaths[1, 3:18]/eucoviddeaths[1, 2], type='l', col=colors[1], main = "deaths per capita versus day", xlab='March 2020', ylab='# deaths per capita', ylim=c(0, max(eucoviddeaths[, 3:18]/eucoviddeaths[, 2])))
for(i in 2:nrow(eucoviddeaths)) {
  lines(16:31, eucoviddeaths[i, 3:18]/eucoviddeaths[i, 2], col=colors[i])
  
}
legend("topleft", legend = paste(eucoviddeaths$Country), col = colors[1:15], pch = 19, bty = "n")

###################################################################################
# Q2
# Countries that have no deaths reported
###################################################################################

eucoviddeaths$total <- 0

for(i in 1:nrow(eucoviddeaths)) {
  eucoviddeaths[i, 'total'] <- sum(eucoviddeaths[i, 3:18])
}

eucoviddeaths[which(eucoviddeaths$total==0), ]$Country


###################################################################################
# Q3.b
# JAGS Model for the posterior distributions
###################################################################################
model {

  for (i in 1:length(logpopulation)) {

    for (j in 1:length(daycent)) {
      deaths[i,j] ~ dpois(lambda[i,j])
      log(lambda[i,j]) <- logpopulation[i] + intercept[i] + slope*daycent[j]
    }

    intercept[i] ~ dnorm(mu.intercept, 1/sigma.intercept^2)

  }

  slope ~ dnorm(0, 1/100^2)
  
  mu.intercept ~ dnorm(0, 1/100^2)
  sigma.intercept ~ dunif(0, 100)

}


###################################################################################
# Q3.c
# JAGS Model for the posterior distributions: First Model Computations
###################################################################################

# Data
d1 <- list(logpopulation = log(eucoviddeaths$PopulationM),
           deaths = eucoviddeaths[, 3:18],
           daycent = as.vector(scale(16:31, scale = FALSE)))

# Initialization
inits1 <- list(list(sigma.intercept=0.01, mu.intercept=100, slope=10),
               list(sigma.intercept=100, mu.intercept=-100, slope=10),
               list(sigma.intercept=0.01, mu.intercept=100, slope=-10),
               list(sigma.intercept=100, mu.intercept=-100, slope=-10))

# JAGS model
m1 <- jags.model("firstmodel.bug", d1, inits1, n.chains=4, n.adapt=1000)

# Burn in of 2000
update(m1, 2000)

# 2000 iterations for convergence
x1 <- coda.samples(m1, c("sigma.intercept", "mu.intercept", "slope"), n.iter=2000)

gelman.diag(x1, autoburnin = FALSE, multivariate = FALSE)

# 4000 iterations for analysis
x1 <- coda.samples(m1, c("sigma.intercept", "mu.intercept", "slope", "intercept"), n.iter=4000)

# Trace Plots
plot(x1[, c("sigma.intercept", "mu.intercept", "slope")], smooth=FALSE)

# Effective Size
effectiveSize(x1[, c("sigma.intercept", "mu.intercept", "slope")])


###################################################################################
# Q3.d
# Approximation of hyperparameters: Slope
###################################################################################

# Mean 
summary(x1)$statistics["slope", "Mean"]

# Standard Deviation
summary(x1)$statistics["slope", "SD"]

# 95% central posterior interval
summary(x1)$quantiles["slope", "2.5%"]
summary(x1)$quantiles["slope", "97.5%"]


###################################################################################
# Q3.d
# Approximation of hyperparameters: Intercept Mean
###################################################################################

# Mean 
summary(x1)$statistics["mu.intercept", "Mean"]

# Standard Deviation
summary(x1)$statistics["mu.intercept", "SD"]

# 95% central posterior interval
summary(x1)$quantiles["mu.intercept", "2.5%"]
summary(x1)$quantiles["mu.intercept", "97.5%"]


###################################################################################
# Q3.d
# Approximation of hyperparameters: Standard Deviation
###################################################################################

# Mean 
summary(x1)$statistics["sigma.intercept", "Mean"]

# Standard Deviation
summary(x1)$statistics["sigma.intercept", "SD"]

# 95% central posterior interval
summary(x1)$quantiles["sigma.intercept", "2.5%"]
summary(x1)$quantiles["sigma.intercept", "97.5%"]


###################################################################################
# Q3.e
# Country with the highest/lowest posterior median value for its intercept
###################################################################################
post.samp1 <- as.matrix(x1)[, 1:27]

# highest posterior median
medians.intercept <- apply(post.samp1, 2, FUN = median)
maxmedianintercept <- max(medians.intercept)
eucoviddeaths$Country[which(medians.intercept == maxmedianintercept)]

# lowest posterior median
minmedianintercept <- min(medians.intercept)
eucoviddeaths$Country[which(medians.intercept == minmedianintercept)]


##############################################################################################
# Q3.f
# Approximate the value of (Plummer's) DIC and the associated effective number of parameters
##############################################################################################
dic.samples(m1, 20000)


###################################################################################
# Q4.a
# JAGS Extended Model for the posterior distribution
###################################################################################
model {

  for (i in 1:length(logpopulation)) {

    for (j in 1:length(daycent)) {
      deaths[i,j] ~ dpois(lambda[i,j])
      log(lambda[i,j]) <- logpopulation[i] + intercept[i] + slope[i]*daycent[j]
    }

    intercept[i] ~ dnorm(mu.intercept, 1/sigma.intercept^2)
    
    slope[i] ~ dnorm(mu.slope, 1/sigma.slope^2)

  }

  mu.slope ~ dnorm(0, 1/100^2)
  sigma.slope ~ dunif(0, 100)
  
  mu.intercept ~ dnorm(0, 1/100^2)
  sigma.intercept ~ dunif(0, 100)

}


###################################################################################
# Q4.b
# JAGS Model for the posterior distributions: Second Model Computations
###################################################################################
# Data
d2 <- list(logpopulation = log(eucoviddeaths$PopulationM),
           deaths = eucoviddeaths[, 3:18],
           daycent = as.vector(scale(16:31, scale = FALSE)))

# Initialization
inits2 <- list(list(sigma.intercept=0.01, mu.intercept=100, sigma.slope=0.01, mu.slope=10),
               list(sigma.intercept=100, mu.intercept=-100, sigma.slope=100, mu.slope=10),
               list(sigma.intercept=0.01, mu.intercept=100, sigma.slope=100, mu.slope=-10),
               list(sigma.intercept=100, mu.intercept=-100, sigma.slope=0.01, mu.slope=-10))

# JAGS model
m2 <- jags.model("secondmodel.bug", d2, inits2, n.chains=4, n.adapt=1000)

# Burn in of 2000
update(m2, 2000)

# 2000 iterations for convergence
x2 <- coda.samples(m2, c("sigma.intercept", "mu.intercept", "sigma.slope", "mu.slope"), n.iter=2000)

gelman.diag(x2, autoburnin = FALSE, multivariate = FALSE)

# 8000 iterations for analysis
x2 <- coda.samples(m2, c("sigma.intercept", "mu.intercept", "sigma.slope", "mu.slope", "intercept", "slope"), n.iter=8000)

# Trace Plots
plot(x2[, c("sigma.intercept", "mu.intercept", "sigma.slope", "mu.slope")], smooth=FALSE)

# Effective Size
effectiveSize(x2[, c("sigma.intercept", "mu.intercept", "sigma.slope", "mu.slope")])


###################################################################################
# Q4.c
# Approximate posterior density
###################################################################################
densplot(x2[, "mu.slope"])


###################################################################################
# Q4.d
# Posterior expected intercept
###################################################################################
intercepts <- as.vector(summary(x2)$statistics[paste("intercept[", 1:nrow(eucoviddeaths),"]", sep=""), "Mean"])
slopes <- as.vector(summary(x2)$statistics[paste("slope[", 1:nrow(eucoviddeaths),"]", sep=""), "Mean"])

plot(x = intercepts, y = slopes, type="n")
text(intercepts, slopes, eucoviddeaths$Country, cex=0.8)


#############################################################################################
# Q4.e
# Approximate the value of (Plummer's) DIC and the associated effective number of parameters
#############################################################################################
dic.samples(m2, 20000)

```